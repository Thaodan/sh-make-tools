#!/bin/sh
# this file contains functions functions that are 100% POSIX compatible
#
# Copyright (C) 2012  BjÃ¶rn Bidar
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

appname=`basename $0`
libsh_ver=2.2
LIBSH_REV=2000

########################################################################

# base config vars for some functions

readonly IMPORT_LIBRARY_PATH=/usr/lib:/usr/lib32:/usr/local/lib:$HOME/.local/lib # base library path for import if  $SH_LIBRARY_PATH is not set


#########################################################################

import() { # . file with check if already . it
#################################################################
# import sh libs that are in $IMPORT_LIBRARY_PATH and $SH_LIBRARY_PATH
# vars:
# IMPORT_LIBRARY_PATH set by  import
# SH_LIBRARY_PATH     set by user use to add a library path
#################################################################
  unset __imported_libs_count
  old_ifs=$IFS
  IFS=:
  while [ ! $# = 0 ] ; do
    for __lib in $already_imported_libs ; do
      IFS=$old_ifs
      if [ "$__lib" = $1 ] ; then
	  __lib_aready_imported=true
	  __imported_libs_count=$(( $__imported_libs_count + 1 ))
	  break 
      fi
      IFS=:
    done 
    IFS=$old_ifs
    if [   -z $__lib_aready_imported  ] ; then
      if [ $(dirname $1) = . ] ; then	
	for __lib_dir in $( export IFS=: ; find ${IMPORT_LIBRARY_PATH} ${SH_LIBRARY_PATH} -maxdepth 1 -type d; export IFS=$old_ifs) ; do
	  if [ -e $__lib_dir/$1 ] && [ -f $__lib_dir/$1 ] ; then 
	    . ${__lib_dir}/$1
	    break
	  fi
	done
      else
	 . $1
      fi
      already_imported_libs=$already_imported_libs:$1
    fi
    shift
    unset __lib_aready_imported
  done  

 # IFS=$old_ifs
  unset  __lib __lib_dir
  return $__imported_libs_count # return how many libs were already imported

}
detectDE() 
# detect which DE is running
# taken from xdg-email script 
{
    if [ x"$KDE_FULL_SESSION" = x"true" ]; then DE=kde;
    elif [ x"$GNOME_DESKTOP_SESSION_ID" != x"" ]; then DE=gnome;
    elif `dbus-send --print-reply --dest=org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus.GetNameOwner string:org.gnome.SessionManager > /dev/null 2>&1` ; then DE=gnome;
    elif xprop -root _DT_SAVE_MODE 2> /dev/null | grep ' = \"xfce4\"$' >/dev/null 2>&1; then DE=xfce;
    else DE=generic 
    fi
}


d_msg() { # display msgs and get input 
#########################################################################################################################
# NOTE: needs kdialog ( or zenity ) to display graphical messages and get input in gui					#
#########################################################################################################################
# usage:														#
#  d_msg [modifer] topic msg												#
#  modifers:														#
#  ! msg is an error/faile message											#
#  i msg is an msg/input ( work's not properly in cgi and with xmessage : terminal)					#
#  f msg is an yes/no msg/test												#
#  l msg is an list of items ( nyi in cgi: terminal)									#
#    no modifer msg is an normal msg											#
#########################################################################################################################
#															#
# vars:															#
# DMSG_GUI_APP=`detectDE` (default)  	# d_msg detects wich DE is installed and uses the equal dialog for displaing	#
# DMSG_GUI_APP=generic 			# only set if dialog for DE not found						#
# DMSG_GUI_APP=gnome|xfce 		# with this you can force d_msg to use zenity					#
# DMSG_GUI_APP=kde 			# with this you can force d_msg to use kdialog					#
#															#
# DMSG_GUI                      	# if not zero use graphical dialog, else cfg gui				#
# DMSG_ICON				# icon that d_msg uses when is runned in gui mode if not set icon xorg is used 	#
#															#
#															#
# DMSG_APP 				# say DMSG to use $DMSG_APP in cli possible vara are dialog and cgi_dialog	#												#	
#															#
#															#	
#															#
#															#
#########################################################################################################################
  if [ ! $# -lt 2 ] ; then
      unset dmsg_return_status
#       cgi_dialog() {
# 	unset cfg_return_stat
# 	case "$1" in 
# 	  !) echo "$2" >&2 ; cgi_return_stat=1;;
# 	  f) echo ""$2" y|n"
# 	     read a 
# 	     if [ ! $a = [Yy]* ] ; then
# 	      cgi_return_stat=1
# 	     fi
# 	     ;;
# 	  i) echo "$2"
# 	     read  a 
# 	     if [ -z "$a" ] ; then
# 		cgi_return_stat=1
# 	     fi
# 	     #echo "$a"
# 	     
# 	     ;;
# 	  *) echo "$1" ;;
# 	esac
# 
# 	return ${cgi_return_stat:-0}
#       }
      if [  ${DMSG_GUI} = true ] > /dev/null 2>&1 || [ ! $DMSG_GUI = 0 ] > /dev/null 2>&1 ; then
	if [  -z "$DMSG_GUI_APP" ] ; then
	    detectDE
	    DMSG_GUI_APP=$DE
	    case "$DMSG_GUI_APP" in 
		kde)   	    which  kdialog  > /dev/null  || which > /dev/null  zenity  && DMSG_GUI_APP=kde     || DMSG_GUI_APP=generic ;; #  && echo "Warning: dialog programm for DE not found using xmessage as poor substitute" ;;
		gnome|xfce) which zenity   > /dev/null   || which  kdialog  > /dev/null  && DMSG_GUI_APP=gnome   || DMSG_GUI_APP=generic ;; # && echo "Warning: dialog programm for DE not found using xmessage as poor substitute" ;;
		*) which kdialog > /dev/null  && DMSG_GUI_APP=kde || need zenity && DMSG_GUI_APP=zenity  || DMSG_GUI_APP=generic ;; # && echo "Warning: dialog programm for DE not found using xmessage as poor substitute" ;;
	    esac 
	fi
	    
	#DE=gnome
	case $DMSG_GUI_APP in 
	  kde)
	    case $1 in 
	      !) kdialog --icon ${DMSG_ICON:=xorg} --caption "${APPNAME:=$appname}" --title "$2" --error "$3" ; dmsg_return_status=${DMG_ERR_STAUS:=1}  ;;
	      i) kdialog --icon ${DMSG_ICON:=xorg} --caption "${APPNAME:=$appname}" --title "$2" --inputbox "$3" ; dmsg_return_status=$? ;;
	      l) kdialog --icon ${DMSG_ICON:=xorg} --caption "${APPNAME:=$appname}" --title "$2" --menu "$3" "$4" "$5" "$6" "$7" "$8" "$9" ; shift ; dmsg_return_status=$? ;;
	      f) kdialog --icon ${DMSG_ICON:=xorg} --caption "${APPNAME:=$appname}"  --title "$2" --yesno "$3" ; dmsg_return_status=$? ;;
	      *) kdialog --icon ${DMSG_ICON:=xorg} --caption "${APPNAME:=$appname}"  --title "$1" --msgbox "$2" ; dmsg_return_status=$? ;;
	    esac
	    ;;
	 xfce|gnome) #nyi impleted
	    case $1 in 
	      !) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2 - ${APPNAME:=$appname}" --error  --text="$3" ;dmsg_return_status=${DMG_ERR_STAUS:=1}   ;;
	      i) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2 - ${APPNAME:=$appname}" --entry --text="$3"  dmsg_return_status=$? ;;
	      l) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2  -${APPNAME:=$appname}" --column='' --text="$3" --list ; dmsg_return_status=$? ;;
	      f) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2  -${APPNAME:=$appname}" --question --text="$3" ; dmsg_return_status=$? ;;
	      *) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$1  -${APPNAME:=$appname}" --info --text="$2" ; dmsg_return_status=$? ;;
	    esac
	    ;;
	 *)
	  case $1 in
	    !) xmessage -center -title "$2 - ${APPNAME:=$appname}" "err: "$3"" ;dmsg_return_status=${DMG_ERR_STAUS:=1}   ;;
	    f) xmessage -center -title "$2  -${APPNAME:=$appname}" -buttons no:1,yes:0 "$3" ; dmsg_return_status=$? ;;	
	    i) if [ -z $buttons ] ; then
		buttons='not:1,set:2'
	       fi
	       xmessage -center -title "$appname - "$2"" -print -buttons $buttons "$3"
               dmsg_return_status=$?
	       ;;
	    l) xmessage -center -title "$2 - ${APPNAME:=$appname}" -print -buttons "$3","$4","$5","$6","$7","$8","$9" ; dmsg_return_status=$? ;;
	    *) xmessage -center -title "$1 - ${APPNAME:=$appname}" "$2" ; dmsg_return_status=$? ;;
	  esac
	 ;;
	esac
	else
	  if [ -z $DMSG_APP ] ; then 
	   if [ ! -z $DMSG_DIALOG_DISABLED ] ; then
	     DMSG_APP=cgi_dialog 
	   else 
	     which dialog > /dev/null  && DMSG_APP=dialog 
	   fi
	  fi
	  case $DMSG_APP in
	    dialog)
	      case "$1" in 
	        !) dialog --title "$2 -${APPNAME:=$appname}" --infobox "error:$3" 0 0 ;;
		#!) cgi_dialog ! "$3" ; dmsg_return_status=${DMG_ERR_STAUS:=1}  ;;
		f) dialog --title "$2 - ${APPNAME:=$appname}" --yesno "$3"   0 0 
		  dmsg_return_status=$?
		    ;;
		i) dialog --title "$2 - ${APPNAME:=$appname}" --inputbox "$3" 0 0
		  dmsg_return_status=$?		 
		  ;;
		*) dialog --title "$1 -${APPNAME:=$appname}" --infobox "$2" 0 0  ;;
		#*) cgi_dialog "$2" ; dmsg_return_status=$? ;;
	      esac
	      ;;
	    cgi_dialog)
	      case "$1" in
		!) echo  "$3" ; dmsg_return_status=${DMG_ERR_STAUS:=1}  ;;
		f) echo ""$3" y|n"
		   read a 
		   if [ ! $a = y ] ; then
		     dmsg_return_status=1;
		   fi
		   ;;
		i) echo "$3"
		   read  a 
		   if [ -z "$a" ] ; then
		    dmsg_return_status=1;
		   fi
		   ;;
		*) echo "$2"   ; dsmg_return_status=$? ;;
	      esac
	      ;;
	  esac
	  
      fi
  fi
return $dmsg_return_status
}


test_input () { # test if input is right 
# test_input with fake arrays instead of real arrays
#   old_ifs=$IFS
  i_p=$(( $# + 1 ))
  current_err_msg="$( read_farray "$err_input_messages" $i_p )"
   if [ -n "$current_err_msg" ] ; then
    d_msg ! 'wrong input' "$current_err_msg"
    if [   $# = 0   ]; then
      return 1
    else
      return 
    fi
  fi
#   IFS=$old_ifs
}


## functions for fake_arrays ########################################################################
# fake arrays are array emulated by using : as $IFS
#
#
#####################################################################################################
# NOTE:
# unlike arrays normal arrays the index of arrays starts with 1 instead of 0
# if a fake_array function gets a 0 as index parameter all entrys in the array where selected 
#
# 	for example:
#
#		var=`read_farray fu:bar 0`
#	       +var='fu bar'
#####################################################################################################	

get_farray_lenght() { # get lenght of fake array
  if [ $# -ge 1 ] ; then 
    old_ifs=$IFS
    IFS=:
    for var in $1 ; do
	get_farry_lenght_count=$(( $get_farry_lenght_count + 1 ))
    done
    IFS=$old_ifs
    echo	$get_farry_lenght_count
    unset get_farry_lenght_count var
  else
    echo 0
  fi
}

read_farray() { # read fake array

  if [ $# = 2 ] ; then
  #  _read_farry_number=$2
  #  _read_farry_lenght=`get_farray_lenght "$1"` || return 
   # if [  $2 -le $_read_farry_lenght ] ; then
		old_ifs=$IFS
		IFS=:
		for var in  $1 ; do
			_read_farry_count=$(( $_read_farry_count + 1 ))
			if [ $2 -eq  $_read_farry_count ] || [ $2 -eq 0 ] ; then
				if [ ! -z $var ] ; then
					echo $var
				fi
			fi
		done
		IFS=$old_ifs
    fi
 # fi
  unset _read_farry_count  var
}

write_farray() {  # write fake array   
# write_farry farry 1 test
	if [ $# -eq 3 ] ; then
		farry_content=$( eval echo \$$1)
		if [ ! -z "$farry_content" ] ; then 
			eval $( echo $1)=$( echo $farry_content | sed "s/$(read_farray $farry_content $2 )/$3/")
		elif [ $2 = 1 ] ; then
			eval $1=$3
		else
			return 1
		fi
	fi
}


## function that help to handle temp dirs ##


# _mk_temp_dir() { #obsolent
#   temp=`mktemp -d `date +%s%t`XXXXXXXXXX`
#   {
#   trap "rm -rf $temp" SIGINT SIGTERM SIGKILL
#   }
#   
#   readonly $temp
#   return 
# }
