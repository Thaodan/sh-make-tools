#!/bin/sh
# syntax: $0 [ --debug ] version:rev target 
# sh_make configure replacment with make functions

# Copyright (C) 2012  BjÃ¶rn Bidar
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#### load base tools (shared)
. "@prefix@/lib/sh_make/libsh_make"
# config
###################################
err_input_messages='No input given or no sh_makefile found!:Wrong or to less  input given!' # err message for test_input
MODULE_PATH=@prefix@/lib/sh_make/modules # default module path if no overwridden

####################################

### private tools ###
cleanup() {
  if [ ! $keep ] ; then
    old_ifs=$IFS
    export IFS=:;rm -rf $files_to_remove; 
  
    export IFS=$old_ifs
  fi
}

cleanup_die() {
  cleanup
}
call_handler() {
  case $1 in
    error*) error "$@"; die=1 ;;
    warning*) test ! -z  $WARNING_IS_ERROR = true && die=1; warning "$@";; 
  esac
  if [ $die ]  ; then
    verbose 'got signal to die, dieing'
    cleanup_die
    exit ${assumed_err_status:-13}
  fi
}

list_entrys() {
    grep -E '*\(\)' $sh_makefile | sed 's|{||'
}
### main ###
main() {
  if [ ! $used_shell ] ; then 
      first_line=$( sed -e '2,$ d' "$sh_makefile" ) 
      if echo "$first_line" | grep '#!' ; then # if we found no shebang use /bin/sh as default shell
	  echo "$first_line" | sed -e 's|#\!||' || used_shell=/bin/sh 
      else
	  used_shell=/bin/sh
      fi
  fi
  "${used_shell:-/bin/sh}" -n "$sh_makefile"  || call_handler error:syntax "$used_shell exited with $? syntax check for $sh_makefile"

  if [ -z $tmp_dir ] ; then
      tmp_dir=tmp
      mkdir -p $tmp_dir
  else
      mkdir -p $tmp_dir
     if  [ ! -z $(ls $tmp_dir )  ] ; then
	call_handler warning:dir "$tmp_dir already exits, hmm"
      fi
  fi

# gen dynamic config stuff and init basic stuff
cat > "$tmp_dir/env" <<_ENV
USED_SHELL=$used_shell     
MODULE_PATH=$MODULE_PATH
chained_vars=$chained_vars
$( for chain in $chained_vars ; do \
echo "$chain=$( eval echo \$my_$chain)"; done)
old_ifs=\$IFS
IFS=:
for chain in \$chained_vars ; do
  eval \$chain=\$( eval echo \\\$\$chain )
done
USE_COLOR=$USE_COLOR
init_stats
_ENV

if [ "$debug_options" ] && [ ! $debug ] ; then
   echo "set -o $debug_options" >> "$tmp_dir/env"
fi






#
  # run used shell give it our main functions that we have, load the generated env file, load the main_module while inits module handling and such and than load the sh_makefile so that it can run with the given functions
  "$used_shell"  -c$debug ". @prefix@/lib/sh_make/libsh_make; . @prefix@/lib/sh_make/modules/main_module; test ! -z $temp_sh_makefile_dir &&  cd $temp_sh_makefile_dir; . $sh_makefile;. $PWD/$tmp_dir/env; run_entry_point $entry_points"  || call_handler error:exit "got error $? while running $sh_makefile"  


  files_to_remove=$tmp_dir


  cleanup


}

print_help() {
  cat <<EOF
$appname usage:
     $appname [Options] entry_point
  Options:
  --help    -H -h                    print this help
  --version -V                       print version
  --color   -c                       enable colored output
EOF
}
### input parser ###
init_stats
case $1 in 
  --help|-H|-h)	print_help ;; 
  --revision) 	echo $SH_MAKE_REV ;;
  --version)	echo $SH_MAKE_VER:$SH_MAKE_REV  ;;
#   #-*)		echo `read_farray "$err_input_messages" 1`;;
  --*|*)
    optspec=s:f: # b:dp # short options
    optspec_long=shell:,make:,keep,debug,verbose,debug-full,verbose-full,mod-path,list-entrys # long options
    PROCESSED_OPTSPEC=`getopt -q --options $optspec --long $optspec_long \
    -n $appname --  "$@"` ||  error  "Wrong or to less  input given!" || exit 1 # parsed optspec
    eval set -- "$PROCESSED_OPTSPEC"
    while [ ! $# = 0 ] ; do
      case $1 in 
	-s|--shell) used_shell="$2"; readonly used_shell ; shift 2;;
	--list-entrys) main_runner=list_entrys; break ;shift;;
	--debug-full) debug=xv ; USE_COLOR=n;  shift ;;
        --verbose-full) debug=v ;USE_COLOR=n;  shift ;;
	--debug) debug_options='xtrace verbose' ; shift ;;
	--verbose) debug_options='verbose' ; shift ;;
	-f|--make) sh_makefile="$2" ; shift 2 ;;
	--mod-path) MODULE_PATH="$2"; shift 2 ;;
	--keep) keep=true; shift ;; # dont remove tmp dir
	--color|-c) USE_COLOR=y ; shift ;;
	--) shift ; break
      esac
    done
  	  for var in $1 ; do
	    case $1 in
	      	      *=*)
		eval my_$1
		if [ -z $chained_vars ] ; then
		  chained_vars=$( echo $1 | cut -d '=' -f1 )
		else
		  chained_vars=$chained_vars:$( echo $1 | cut -d '=' -f1 )
		fi
		shift
		;;
	    esac
	  done
    
    if [ ! -z "$sh_makefile" ]  ; then
      temp_sh_makefile_dir=$( dirname $sh_makefile )
      sh_makefile=$PWD/$sh_makefile
      

     # sh_makefile=${temp_sh_makefile_dir}$sh_makefile
     
  
    elif [ -e "$PWD/sh_makefile" ] ; then # if input is less $1  input given and sh_makefile exists in $PWD use it 
      sh_makefile=$PWD/sh_makefile
#       [ ! -z "$1" ]  && entry_point="$1" || true
#     elif [ "$1" = --make ] || [ "$1" = -f ] ; then # if input has option to use another sh_makefile use it 
#       sh_makefile="$2"
#       shift 2
    else
      echo "No input given or sh_makefile found"
      false 
    fi && \
    entry_points="${@:-default}" && \
    ${main_runner:-main}
  ;;
esac 


